<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>libinput: Initialization and manipulation of libinput contexts</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="bootstrap.css" rel="stylesheet" type="text/css"/>
        <link href="bootstrap.css" rel="stylesheet" type="text/css" />
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">libinput 1.6.3</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Initialization and manipulation of libinput contexts</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibinput.html">libinput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for accessing libinput.  <a href="structlibinput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibinput__interface.html">libinput_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">libinput does not open file descriptors to devices directly, instead <a class="el" href="structlibinput__interface.html#ae445aaa330e4eb7df6650fbc6428022a" title="Open the device at the given path with the flags provided and return the fd. ">open_restricted()</a> and <a class="el" href="structlibinput__interface.html#af78e15d6a06bc928d8679b587bb4e8fa" title="Close the file descriptor. ">close_restricted()</a> are called for each path that must be opened.  <a href="structlibinput__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa16223d9fa8b6e3ac7c722e184f2217f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gaa16223d9fa8b6e3ac7c722e184f2217f">libinput_log_handler</a>) (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, enum <a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> priority, const char *format, va_list args) <a class="el" href="libinput_8h.html#a7de828556e8e12b23e4c5acec1581780">LIBINPUT_ATTRIBUTE_PRINTF</a>(3</td></tr>
<tr class="memdesc:gaa16223d9fa8b6e3ac7c722e184f2217f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log handler type for custom logging.  <a href="#gaa16223d9fa8b6e3ac7c722e184f2217f">More...</a><br /></td></tr>
<tr class="separator:gaa16223d9fa8b6e3ac7c722e184f2217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf00228a43c831817ba6ec0b94b9df74"><td class="memItemLeft" align="right" valign="top">typedef void(*) voi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gacf00228a43c831817ba6ec0b94b9df74">libinput_log_set_handler</a>) (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, <a class="el" href="group__base.html#gaa16223d9fa8b6e3ac7c722e184f2217f">libinput_log_handler</a> log_handler)</td></tr>
<tr class="memdesc:gacf00228a43c831817ba6ec0b94b9df74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the context's log handler.  <a href="#gacf00228a43c831817ba6ec0b94b9df74">More...</a><br /></td></tr>
<tr class="separator:gacf00228a43c831817ba6ec0b94b9df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa7e9ebbd1a13fe2ed6f44e69df3216e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> { <a class="el" href="group__base.html#ggaa7e9ebbd1a13fe2ed6f44e69df3216e1a3f46e5b7430e100479b4ea27f0fbb1f8">LIBINPUT_LOG_PRIORITY_DEBUG</a>, 
<a class="el" href="group__base.html#ggaa7e9ebbd1a13fe2ed6f44e69df3216e1a9b457be58d6cf5d66ea177aa3d2c5500">LIBINPUT_LOG_PRIORITY_INFO</a>, 
<a class="el" href="group__base.html#ggaa7e9ebbd1a13fe2ed6f44e69df3216e1ad79f66fcf1d6cbd03678cfc5b012b83d">LIBINPUT_LOG_PRIORITY_ERROR</a>
 }<tr class="memdesc:gaa7e9ebbd1a13fe2ed6f44e69df3216e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log priority for internal logging messages.  <a href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaa7e9ebbd1a13fe2ed6f44e69df3216e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30276a06e8b1434b959f2c8dde74f7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a> { <br />
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cabccc2f8bdff4e6ff42d3e1318864af67">LIBINPUT_EVENT_NONE</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4da18343b29cc16ae2df09b9a3bff33b">LIBINPUT_EVENT_DEVICE_ADDED</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09">LIBINPUT_EVENT_DEVICE_REMOVED</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca477833897722f621bd10bbf3771302d3">LIBINPUT_EVENT_KEYBOARD_KEY</a>, 
<br />
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca1812725b7fac7f096cb5d667a6bf89e9">LIBINPUT_EVENT_POINTER_MOTION</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca5e277107f22df970e882ef76dd6cc315">LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca26d8ced7a6e63edefb7f72ddd4d1d689">LIBINPUT_EVENT_POINTER_BUTTON</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca507673764d93c8d46109b069a3ab9bde">LIBINPUT_EVENT_POINTER_AXIS</a>, 
<br />
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7caa14993972db3e944b4e3f5e74dd99dcb">LIBINPUT_EVENT_TOUCH_DOWN</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca1b48aaefbee80a1cbbcb5986d650bc62">LIBINPUT_EVENT_TOUCH_UP</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7caa96855d3716c4dccd47a69753ed2d468">LIBINPUT_EVENT_TOUCH_MOTION</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7caaf4ed8adce078146aedac569e3178052">LIBINPUT_EVENT_TOUCH_CANCEL</a>, 
<br />
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca2b9b566a3bf1f460a144456697ee7387">LIBINPUT_EVENT_TOUCH_FRAME</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1">LIBINPUT_EVENT_TABLET_TOOL_AXIS</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4f726f7db59c83dd948a5ea1d59f57b8">LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca97e12980dafac44aa6b4501e1a6c9a7a">LIBINPUT_EVENT_TABLET_TOOL_TIP</a>, 
<br />
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca72cb2d7532fb3116debc00d7eecebfa9">LIBINPUT_EVENT_TABLET_TOOL_BUTTON</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca8b1be0a98eba05bd046a15ad32b18a74">LIBINPUT_EVENT_TABLET_PAD_BUTTON</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca243f5e4a62b72c2ff15d2b025a91e70f">LIBINPUT_EVENT_TABLET_PAD_RING</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca2b66dc7ee62f549a3f63217977a5a306">LIBINPUT_EVENT_TABLET_PAD_STRIP</a>, 
<br />
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca6a12d78aa41a5e03daeb60bfc8a540d9">LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7caadbcbf32ccc89daf92197a4d205b213d">LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca0f8de0891bfb23805bedf93c32e1dcb6">LIBINPUT_EVENT_GESTURE_SWIPE_END</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cae431f9d5995d1ad62154454000e7fae0">LIBINPUT_EVENT_GESTURE_PINCH_BEGIN</a>, 
<br />
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cadc7310d99139bb0b1f19fb72358d31dc">LIBINPUT_EVENT_GESTURE_PINCH_UPDATE</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca9aa7b3d9e5801fe356a1b8b5ef42216c">LIBINPUT_EVENT_GESTURE_PINCH_END</a>
<br />
 }<tr class="memdesc:gac30276a06e8b1434b959f2c8dde74f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event type for events returned by <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a>.  <a href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gac30276a06e8b1434b959f2c8dde74f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7512ea602d4b259085c47f6374b078d1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga7512ea602d4b259085c47f6374b078d1">libinput_udev_create_context</a> (const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *interface, void *user_data, struct udev *udev)</td></tr>
<tr class="memdesc:ga7512ea602d4b259085c47f6374b078d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new libinput context from udev.  <a href="#ga7512ea602d4b259085c47f6374b078d1">More...</a><br /></td></tr>
<tr class="separator:ga7512ea602d4b259085c47f6374b078d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a60660b30cb476495e75766222d144"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga71a60660b30cb476495e75766222d144">libinput_udev_assign_seat</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, const char *seat_id)</td></tr>
<tr class="memdesc:ga71a60660b30cb476495e75766222d144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a seat to this libinput context.  <a href="#ga71a60660b30cb476495e75766222d144">More...</a><br /></td></tr>
<tr class="separator:ga71a60660b30cb476495e75766222d144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363c6b6e47dcf410a3b3ebd5547c8b07"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07">libinput_path_create_context</a> (const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *interface, void *user_data)</td></tr>
<tr class="memdesc:ga363c6b6e47dcf410a3b3ebd5547c8b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new libinput context that requires the caller to manually add or remove devices with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a> and <a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121" title="Remove a device from a libinput context initialized with libinput_path_create_context() or added to s...">libinput_path_remove_device()</a>.  <a href="#ga363c6b6e47dcf410a3b3ebd5547c8b07">More...</a><br /></td></tr>
<tr class="separator:ga363c6b6e47dcf410a3b3ebd5547c8b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa797496f0150b482a4e01376bd33a47b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b">libinput_path_add_device</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, const char *path)</td></tr>
<tr class="memdesc:gaa797496f0150b482a4e01376bd33a47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a device to a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a>.  <a href="#gaa797496f0150b482a4e01376bd33a47b">More...</a><br /></td></tr>
<tr class="separator:gaa797496f0150b482a4e01376bd33a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb53cdcce2c000001ac17706a612121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121">libinput_path_remove_device</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga9cb53cdcce2c000001ac17706a612121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device from a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a> or added to such a context with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a>.  <a href="#ga9cb53cdcce2c000001ac17706a612121">More...</a><br /></td></tr>
<tr class="separator:ga9cb53cdcce2c000001ac17706a612121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885a59371d4e8de0e18a2a2a66942e11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga885a59371d4e8de0e18a2a2a66942e11">libinput_get_fd</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:ga885a59371d4e8de0e18a2a2a66942e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">libinput keeps a single file descriptor for all events.  <a href="#ga885a59371d4e8de0e18a2a2a66942e11">More...</a><br /></td></tr>
<tr class="separator:ga885a59371d4e8de0e18a2a2a66942e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271f910ed17461830e48d4cd20483a00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00">libinput_dispatch</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:ga271f910ed17461830e48d4cd20483a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main event dispatchment function.  <a href="#ga271f910ed17461830e48d4cd20483a00">More...</a><br /></td></tr>
<tr class="separator:ga271f910ed17461830e48d4cd20483a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacead6670eaecf7c807659e2b6c725630"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__event.html">libinput_event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630">libinput_get_event</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:gacead6670eaecf7c807659e2b6c725630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next event from libinput's internal event queue.  <a href="#gacead6670eaecf7c807659e2b6c725630">More...</a><br /></td></tr>
<tr class="separator:gacead6670eaecf7c807659e2b6c725630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86ad3c0c5bc27d8f630264f46cdf005"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gac86ad3c0c5bc27d8f630264f46cdf005">libinput_next_event_type</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:gac86ad3c0c5bc27d8f630264f46cdf005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the next event in the internal queue.  <a href="#gac86ad3c0c5bc27d8f630264f46cdf005">More...</a><br /></td></tr>
<tr class="separator:gac86ad3c0c5bc27d8f630264f46cdf005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a020ab0a0da92749e24e80538ab28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gac1a020ab0a0da92749e24e80538ab28f">libinput_set_user_data</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, void *user_data)</td></tr>
<tr class="memdesc:gac1a020ab0a0da92749e24e80538ab28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set caller-specific data associated with this context.  <a href="#gac1a020ab0a0da92749e24e80538ab28f">More...</a><br /></td></tr>
<tr class="separator:gac1a020ab0a0da92749e24e80538ab28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eab49413b8430c2eee987a39f4a410b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga3eab49413b8430c2eee987a39f4a410b">libinput_get_user_data</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:ga3eab49413b8430c2eee987a39f4a410b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the caller-specific data associated with this context, if any.  <a href="#ga3eab49413b8430c2eee987a39f4a410b">More...</a><br /></td></tr>
<tr class="separator:ga3eab49413b8430c2eee987a39f4a410b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1ee92fa05df27e3c0f37d524cc17a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6">libinput_resume</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:ga5a1ee92fa05df27e3c0f37d524cc17a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a suspended libinput context.  <a href="#ga5a1ee92fa05df27e3c0f37d524cc17a6">More...</a><br /></td></tr>
<tr class="separator:ga5a1ee92fa05df27e3c0f37d524cc17a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60662dc666f6188dc207467c9d8e99ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga60662dc666f6188dc207467c9d8e99ab">libinput_suspend</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:ga60662dc666f6188dc207467c9d8e99ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend monitoring for new devices and close existing devices.  <a href="#ga60662dc666f6188dc207467c9d8e99ab">More...</a><br /></td></tr>
<tr class="separator:ga60662dc666f6188dc207467c9d8e99ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff29392ec52e1e7de5bb812e085127a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gafff29392ec52e1e7de5bb812e085127a">libinput_ref</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:gafff29392ec52e1e7de5bb812e085127a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a reference to the context.  <a href="#gafff29392ec52e1e7de5bb812e085127a">More...</a><br /></td></tr>
<tr class="separator:gafff29392ec52e1e7de5bb812e085127a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ed0797d23e34b650e0aeb98b5350309"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga7ed0797d23e34b650e0aeb98b5350309">libinput_unref</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:ga7ed0797d23e34b650e0aeb98b5350309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the libinput context.  <a href="#ga7ed0797d23e34b650e0aeb98b5350309">More...</a><br /></td></tr>
<tr class="separator:ga7ed0797d23e34b650e0aeb98b5350309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a500c54c61cfcecd4c76dbb8022933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga75a500c54c61cfcecd4c76dbb8022933">libinput_log_set_priority</a> (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, enum <a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> priority)</td></tr>
<tr class="memdesc:ga75a500c54c61cfcecd4c76dbb8022933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the log priority for the libinput context.  <a href="#ga75a500c54c61cfcecd4c76dbb8022933">More...</a><br /></td></tr>
<tr class="separator:ga75a500c54c61cfcecd4c76dbb8022933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7367998ca39a6e873920ba5e2a12d4f0"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga7367998ca39a6e873920ba5e2a12d4f0">libinput_log_get_priority</a> (const struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>)</td></tr>
<tr class="memdesc:ga7367998ca39a6e873920ba5e2a12d4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context's log priority.  <a href="#ga7367998ca39a6e873920ba5e2a12d4f0">More...</a><br /></td></tr>
<tr class="separator:ga7367998ca39a6e873920ba5e2a12d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa16223d9fa8b6e3ac7c722e184f2217f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa16223d9fa8b6e3ac7c722e184f2217f">&#9670;&nbsp;</a></span>libinput_log_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* libinput_log_handler) (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, enum <a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> priority, const char *format, va_list args) <a class="el" href="libinput_8h.html#a7de828556e8e12b23e4c5acec1581780">LIBINPUT_ATTRIBUTE_PRINTF</a>(3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log handler type for custom logging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>The libinput context </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the current message </td></tr>
    <tr><td class="paramname">format</td><td>Message format in printf-style </td></tr>
    <tr><td class="paramname">args</td><td>Message arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__base.html#ga75a500c54c61cfcecd4c76dbb8022933" title="Set the log priority for the libinput context. ">libinput_log_set_priority</a> </dd>
<dd>
<a class="el" href="group__base.html#ga7367998ca39a6e873920ba5e2a12d4f0" title="Get the context&#39;s log priority. ">libinput_log_get_priority</a> </dd>
<dd>
<a class="el" href="group__base.html#gacf00228a43c831817ba6ec0b94b9df74" title="Set the context&#39;s log handler. ">libinput_log_set_handler</a> </dd></dl>

</div>
</div>
<a id="gacf00228a43c831817ba6ec0b94b9df74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf00228a43c831817ba6ec0b94b9df74">&#9670;&nbsp;</a></span>libinput_log_set_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) voi libinput_log_set_handler) (struct <a class="el" href="structlibinput.html">libinput</a> *<a class="el" href="structlibinput.html">libinput</a>, <a class="el" href="group__base.html#gaa16223d9fa8b6e3ac7c722e184f2217f">libinput_log_handler</a> log_handler)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the context's log handler. </p>
<p>Messages with priorities equal to or higher than the context's log priority will be passed to the given log handler.</p>
<p>The default log handler prints to stderr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
    <tr><td class="paramname">log_handler</td><td>The log handler for library messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__base.html#ga75a500c54c61cfcecd4c76dbb8022933" title="Set the log priority for the libinput context. ">libinput_log_set_priority</a> </dd>
<dd>
<a class="el" href="group__base.html#ga7367998ca39a6e873920ba5e2a12d4f0" title="Get the context&#39;s log priority. ">libinput_log_get_priority</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac30276a06e8b1434b959f2c8dde74f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac30276a06e8b1434b959f2c8dde74f7c">&#9670;&nbsp;</a></span>libinput_event_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event type for events returned by <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7cabccc2f8bdff4e6ff42d3e1318864af67"></a>LIBINPUT_EVENT_NONE&#160;</td><td class="fielddoc"><p>This is not a real event type, and is only used to tell the user that no new event is available in the queue. </p>
<p>See <a class="el" href="group__base.html#gac86ad3c0c5bc27d8f630264f46cdf005" title="Return the type of the next event in the internal queue. ">libinput_next_event_type()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca4da18343b29cc16ae2df09b9a3bff33b"></a>LIBINPUT_EVENT_DEVICE_ADDED&#160;</td><td class="fielddoc"><p>Signals that a device has been added to the context. </p>
<p>The device will not be read until the next time the user calls <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> and data is available.</p>
<p>This allows setting up initial device configuration before any events are created. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09"></a>LIBINPUT_EVENT_DEVICE_REMOVED&#160;</td><td class="fielddoc"><p>Signals that a device has been removed. </p>
<p>No more events from the associated device will be in the queue or be queued after this event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca477833897722f621bd10bbf3771302d3"></a>LIBINPUT_EVENT_KEYBOARD_KEY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca1812725b7fac7f096cb5d667a6bf89e9"></a>LIBINPUT_EVENT_POINTER_MOTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca5e277107f22df970e882ef76dd6cc315"></a>LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca26d8ced7a6e63edefb7f72ddd4d1d689"></a>LIBINPUT_EVENT_POINTER_BUTTON&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca507673764d93c8d46109b069a3ab9bde"></a>LIBINPUT_EVENT_POINTER_AXIS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7caa14993972db3e944b4e3f5e74dd99dcb"></a>LIBINPUT_EVENT_TOUCH_DOWN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca1b48aaefbee80a1cbbcb5986d650bc62"></a>LIBINPUT_EVENT_TOUCH_UP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7caa96855d3716c4dccd47a69753ed2d468"></a>LIBINPUT_EVENT_TOUCH_MOTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7caaf4ed8adce078146aedac569e3178052"></a>LIBINPUT_EVENT_TOUCH_CANCEL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca2b9b566a3bf1f460a144456697ee7387"></a>LIBINPUT_EVENT_TOUCH_FRAME&#160;</td><td class="fielddoc"><p>Signals the end of a set of touchpoints at one device sample time. </p>
<p>This event has no coordinate information attached. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1"></a>LIBINPUT_EVENT_TABLET_TOOL_AXIS&#160;</td><td class="fielddoc"><p>One or more axes have changed state on a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability. </p>
<p>This event is only sent when the tool is in proximity, see <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4f726f7db59c83dd948a5ea1d59f57b8">LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY</a> for details.</p>
<p>The proximity event contains the initial state of the axis as the tool comes into proximity. An event of type <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1">LIBINPUT_EVENT_TABLET_TOOL_AXIS</a> is only sent when an axis value changes from this initial state. It is possible for a tool to enter and leave proximity without sending an event of type <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1">LIBINPUT_EVENT_TABLET_TOOL_AXIS</a>.</p>
<p>An event of type <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1">LIBINPUT_EVENT_TABLET_TOOL_AXIS</a> is sent when the tip state does not change. See the documentation for <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca97e12980dafac44aa6b4501e1a6c9a7a">LIBINPUT_EVENT_TABLET_TOOL_TIP</a> for more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca4f726f7db59c83dd948a5ea1d59f57b8"></a>LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY&#160;</td><td class="fielddoc"><p>Signals that a tool has come in or out of proximity of a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability. </p>
<p>Proximity events contain each of the current values for each axis, and these values may be extracted from them in the same way they are with <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1">LIBINPUT_EVENT_TABLET_TOOL_AXIS</a> events.</p>
<p>Some tools may always be in proximity. For these tools, events of type <a class="el" href="group__device.html#gga54f9b346c0338de742583a8e7c2b0628a90e9036c5474e8d5675549ceadcbd5f2">LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN</a> are sent only once after <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4da18343b29cc16ae2df09b9a3bff33b">LIBINPUT_EVENT_DEVICE_ADDED</a>, and events of type <a class="el" href="group__device.html#gga54f9b346c0338de742583a8e7c2b0628aca836e7d6fb61219ba4627ccaf0b47f8">LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT</a> are sent only once before <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09">LIBINPUT_EVENT_DEVICE_REMOVED</a>.</p>
<p>If the tool that comes into proximity supports x/y coordinates, libinput guarantees that both x and y are set in the proximity event.</p>
<p>When a tool goes out of proximity, the value of every axis should be assumed to have an undefined state and any buttons that are currently held down on the stylus are marked as released. Button release events for each button that was held down on the stylus are sent before the proximity out event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca97e12980dafac44aa6b4501e1a6c9a7a"></a>LIBINPUT_EVENT_TABLET_TOOL_TIP&#160;</td><td class="fielddoc"><p>Signals that a tool has come in contact with the surface of a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability. </p>
<p>On devices without distance proximity detection, the <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca97e12980dafac44aa6b4501e1a6c9a7a">LIBINPUT_EVENT_TABLET_TOOL_TIP</a> is sent immediately after <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4f726f7db59c83dd948a5ea1d59f57b8">LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY</a> for the tip down event, and immediately before for the tip up event.</p>
<p>The decision when a tip touches the surface is device-dependent and may be derived from pressure data or other means. If the tip state is changed by axes changing state, the <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca97e12980dafac44aa6b4501e1a6c9a7a">LIBINPUT_EVENT_TABLET_TOOL_TIP</a> event includes the changed axes and no additional axis event is sent for this state change. In other words, a caller must look at both <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1">LIBINPUT_EVENT_TABLET_TOOL_AXIS</a> and <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca97e12980dafac44aa6b4501e1a6c9a7a">LIBINPUT_EVENT_TABLET_TOOL_TIP</a> events to know the current state of the axes.</p>
<p>If a button state change occurs at the same time as a tip state change, the order of events is device-dependent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca72cb2d7532fb3116debc00d7eecebfa9"></a>LIBINPUT_EVENT_TABLET_TOOL_BUTTON&#160;</td><td class="fielddoc"><p>Signals that a tool has changed a logical button state on a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability. </p>
<p>Button state changes occur on their own and do not include axis state changes. If button and axis state changes occur within the same logical hardware event, the order of the <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca72cb2d7532fb3116debc00d7eecebfa9">LIBINPUT_EVENT_TABLET_TOOL_BUTTON</a> and <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cafd96baa20189125ce908b3d65a845de1">LIBINPUT_EVENT_TABLET_TOOL_AXIS</a> event is device-specific.</p>
<p>This event is not to be confused with the button events emitted by the tablet pad. See <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca8b1be0a98eba05bd046a15ad32b18a74">LIBINPUT_EVENT_TABLET_PAD_BUTTON</a>.</p>
<dl class="section see"><dt>See also</dt><dd>LIBINPUT_EVENT_TABLET_BUTTON </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca8b1be0a98eba05bd046a15ad32b18a74"></a>LIBINPUT_EVENT_TABLET_PAD_BUTTON&#160;</td><td class="fielddoc"><p>A button pressed on a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability. </p>
<p>This event is not to be confused with the button events emitted by tools on a tablet. See <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca72cb2d7532fb3116debc00d7eecebfa9">LIBINPUT_EVENT_TABLET_TOOL_BUTTON</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca243f5e4a62b72c2ff15d2b025a91e70f"></a>LIBINPUT_EVENT_TABLET_PAD_RING&#160;</td><td class="fielddoc"><p>A status change on a tablet ring with the LIBINPUT_DEVICE_CAP_TABLET_PAD capability. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca2b66dc7ee62f549a3f63217977a5a306"></a>LIBINPUT_EVENT_TABLET_PAD_STRIP&#160;</td><td class="fielddoc"><p>A status change on a strip on a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca6a12d78aa41a5e03daeb60bfc8a540d9"></a>LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7caadbcbf32ccc89daf92197a4d205b213d"></a>LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca0f8de0891bfb23805bedf93c32e1dcb6"></a>LIBINPUT_EVENT_GESTURE_SWIPE_END&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7cae431f9d5995d1ad62154454000e7fae0"></a>LIBINPUT_EVENT_GESTURE_PINCH_BEGIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7cadc7310d99139bb0b1f19fb72358d31dc"></a>LIBINPUT_EVENT_GESTURE_PINCH_UPDATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggac30276a06e8b1434b959f2c8dde74f7ca9aa7b3d9e5801fe356a1b8b5ef42216c"></a>LIBINPUT_EVENT_GESTURE_PINCH_END&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gaa7e9ebbd1a13fe2ed6f44e69df3216e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">&#9670;&nbsp;</a></span>libinput_log_priority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log priority for internal logging messages. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa7e9ebbd1a13fe2ed6f44e69df3216e1a3f46e5b7430e100479b4ea27f0fbb1f8"></a>LIBINPUT_LOG_PRIORITY_DEBUG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaa7e9ebbd1a13fe2ed6f44e69df3216e1a9b457be58d6cf5d66ea177aa3d2c5500"></a>LIBINPUT_LOG_PRIORITY_INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaa7e9ebbd1a13fe2ed6f44e69df3216e1ad79f66fcf1d6cbd03678cfc5b012b83d"></a>LIBINPUT_LOG_PRIORITY_ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga271f910ed17461830e48d4cd20483a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga271f910ed17461830e48d4cd20483a00">&#9670;&nbsp;</a></span>libinput_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main event dispatchment function. </p>
<p>Reads events of the file descriptors and processes them internally. Use <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a> to retrieve the events.</p>
<p>Dispatching does not necessarily queue libinput events. This function should be called immediately once data is available on the file descriptor returned by <a class="el" href="group__base.html#ga885a59371d4e8de0e18a2a2a66942e11" title="libinput keeps a single file descriptor for all events. ">libinput_get_fd()</a>. libinput has a number of timing-sensitive features (e.g. tap-to-click), any delay in calling <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> may prevent these features from working correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative errno on failure </dd></dl>

</div>
</div>
<a id="gacead6670eaecf7c807659e2b6c725630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacead6670eaecf7c807659e2b6c725630">&#9670;&nbsp;</a></span>libinput_get_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__event.html">libinput_event</a>* libinput_get_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the next event from libinput's internal event queue. </p>
<p>After handling the retrieved event, the caller must destroy it using <a class="el" href="group__event.html#ga1df956c16e26cbbd911e553ec081022a" title="Destroy the event, freeing all associated resources. ">libinput_event_destroy()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next available event, or NULL if no event is available. </dd></dl>

</div>
</div>
<a id="ga885a59371d4e8de0e18a2a2a66942e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga885a59371d4e8de0e18a2a2a66942e11">&#9670;&nbsp;</a></span>libinput_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_get_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>libinput keeps a single file descriptor for all events. </p>
<p>Call into <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> if any events become available on this fd.</p>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor used to notify of pending events. </dd></dl>

</div>
</div>
<a id="ga3eab49413b8430c2eee987a39f4a410b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eab49413b8430c2eee987a39f4a410b">&#9670;&nbsp;</a></span>libinput_get_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* libinput_get_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the caller-specific data associated with this context, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The caller-specific data previously assigned in libinput_create_udev(). </dd></dl>

</div>
</div>
<a id="ga7367998ca39a6e873920ba5e2a12d4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7367998ca39a6e873920ba5e2a12d4f0">&#9670;&nbsp;</a></span>libinput_log_get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> libinput_log_get_priority </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context's log priority. </p>
<p>Messages with priorities equal to or higher than the argument will be printed to the current log handler.</p>
<p>The default log priority is <a class="el" href="group__base.html#ggaa7e9ebbd1a13fe2ed6f44e69df3216e1ad79f66fcf1d6cbd03678cfc5b012b83d">LIBINPUT_LOG_PRIORITY_ERROR</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum priority of log messages to print.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__base.html#gacf00228a43c831817ba6ec0b94b9df74" title="Set the context&#39;s log handler. ">libinput_log_set_handler</a> </dd>
<dd>
<a class="el" href="group__base.html#ga75a500c54c61cfcecd4c76dbb8022933" title="Set the log priority for the libinput context. ">libinput_log_set_priority</a> </dd></dl>

</div>
</div>
<a id="ga75a500c54c61cfcecd4c76dbb8022933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75a500c54c61cfcecd4c76dbb8022933">&#9670;&nbsp;</a></span>libinput_log_set_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_log_set_priority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__base.html#gaa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the log priority for the libinput context. </p>
<p>Messages with priorities equal to or higher than the argument will be printed to the context's log handler.</p>
<p>The default log priority is <a class="el" href="group__base.html#ggaa7e9ebbd1a13fe2ed6f44e69df3216e1ad79f66fcf1d6cbd03678cfc5b012b83d">LIBINPUT_LOG_PRIORITY_ERROR</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
    <tr><td class="paramname">priority</td><td>The minimum priority of log messages to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__base.html#gacf00228a43c831817ba6ec0b94b9df74" title="Set the context&#39;s log handler. ">libinput_log_set_handler</a> </dd>
<dd>
<a class="el" href="group__base.html#ga7367998ca39a6e873920ba5e2a12d4f0" title="Get the context&#39;s log priority. ">libinput_log_get_priority</a> </dd></dl>

</div>
</div>
<a id="gac86ad3c0c5bc27d8f630264f46cdf005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac86ad3c0c5bc27d8f630264f46cdf005">&#9670;&nbsp;</a></span>libinput_next_event_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a> libinput_next_event_type </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the next event in the internal queue. </p>
<p>This function does not pop the event off the queue and the next call to <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a> returns that event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event type of the next available event or <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cabccc2f8bdff4e6ff42d3e1318864af67">LIBINPUT_EVENT_NONE</a> if no event is available. </dd></dl>

</div>
</div>
<a id="gaa797496f0150b482a4e01376bd33a47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa797496f0150b482a4e01376bd33a47b">&#9670;&nbsp;</a></span>libinput_path_add_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__device.html">libinput_device</a>* libinput_path_add_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a device to a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a>. </p>
<p>If successful, the device will be added to the internal list and re-opened on <a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6" title="Resume a suspended libinput context. ">libinput_resume()</a>. The device can be removed with <a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121" title="Remove a device from a libinput context initialized with libinput_path_create_context() or added to s...">libinput_path_remove_device()</a>.</p>
<p>If the device was successfully initialized, it is returned in the device argument. The lifetime of the returned device pointer is limited until the next <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a>, use <a class="el" href="group__device.html#ga3335d55a50f0c2fb0c5f496a3105d467" title="Increase the refcount of the input device. ">libinput_device_ref()</a> to keep a permanent reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
    <tr><td class="paramname">path</td><td>Path to an input device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly initiated device on success, or NULL on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is an application bug to call this function on a libinput context initialized with <a class="el" href="group__base.html#ga7512ea602d4b259085c47f6374b078d1" title="Create a new libinput context from udev. ">libinput_udev_create_context()</a>. </dd></dl>

</div>
</div>
<a id="ga363c6b6e47dcf410a3b3ebd5547c8b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga363c6b6e47dcf410a3b3ebd5547c8b07">&#9670;&nbsp;</a></span>libinput_path_create_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput.html">libinput</a>* libinput_path_create_context </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new libinput context that requires the caller to manually add or remove devices with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a> and <a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121" title="Remove a device from a libinput context initialized with libinput_path_create_context() or added to s...">libinput_path_remove_device()</a>. </p>
<p>The context is fully initialized but will not generate events until at least one device has been added.</p>
<p>The reference count of the context is initialized to 1. See <a class="el" href="group__base.html#ga7ed0797d23e34b650e0aeb98b5350309">libinput_unref</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The callback interface </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data passed to the various callback interfaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized, empty libinput context. </dd></dl>

</div>
</div>
<a id="ga9cb53cdcce2c000001ac17706a612121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb53cdcce2c000001ac17706a612121">&#9670;&nbsp;</a></span>libinput_path_remove_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_path_remove_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a device from a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a> or added to such a context with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a>. </p>
<p>Events already processed from this input device are kept in the queue, the <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09">LIBINPUT_EVENT_DEVICE_REMOVED</a> event marks the end of events for this device.</p>
<p>If no matching device exists, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A libinput device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is an application bug to call this function on a libinput context initialized with <a class="el" href="group__base.html#ga7512ea602d4b259085c47f6374b078d1" title="Create a new libinput context from udev. ">libinput_udev_create_context()</a>. </dd></dl>

</div>
</div>
<a id="gafff29392ec52e1e7de5bb812e085127a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff29392ec52e1e7de5bb812e085127a">&#9670;&nbsp;</a></span>libinput_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput.html">libinput</a>* libinput_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a reference to the context. </p>
<p>A context is destroyed whenever the reference count reaches 0. See <a class="el" href="group__base.html#ga7ed0797d23e34b650e0aeb98b5350309">libinput_unref</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized valid libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed libinput context </dd></dl>

</div>
</div>
<a id="ga5a1ee92fa05df27e3c0f37d524cc17a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a1ee92fa05df27e3c0f37d524cc17a6">&#9670;&nbsp;</a></span>libinput_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_resume </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a suspended libinput context. </p>
<p>This re-enables device monitoring and adds existing devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__base.html#ga60662dc666f6188dc207467c9d8e99ab" title="Suspend monitoring for new devices and close existing devices. ">libinput_suspend</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="gac1a020ab0a0da92749e24e80538ab28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a020ab0a0da92749e24e80538ab28f">&#9670;&nbsp;</a></span>libinput_set_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_set_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set caller-specific data associated with this context. </p>
<p>libinput does not manage, look at, or modify this data. The caller must ensure the data is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data passed to the various callback interfaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60662dc666f6188dc207467c9d8e99ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60662dc666f6188dc207467c9d8e99ab">&#9670;&nbsp;</a></span>libinput_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_suspend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend monitoring for new devices and close existing devices. </p>
<p>This all but terminates libinput but does keep the context valid to be resumed with <a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6" title="Resume a suspended libinput context. ">libinput_resume()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71a60660b30cb476495e75766222d144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a60660b30cb476495e75766222d144">&#9670;&nbsp;</a></span>libinput_udev_assign_seat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_udev_assign_seat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>seat_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a seat to this libinput context. </p>
<p>New devices or the removal of existing devices will appear as events during <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a>.</p>
<p><a class="el" href="group__base.html#ga71a60660b30cb476495e75766222d144" title="Assign a seat to this libinput context. ">libinput_udev_assign_seat()</a> succeeds even if no input devices are currently available on this seat, or if devices are available but fail to open in <a class="el" href="structlibinput__interface.html#ae445aaa330e4eb7df6650fbc6428022a">libinput_interface::open_restricted</a>. Devices that do not have the minimum capabilities to be recognized as pointer, keyboard or touch device are ignored. Such devices and those that failed to open ignored until the next call to <a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6" title="Resume a suspended libinput context. ">libinput_resume()</a>.</p>
<p>This function may only be called once per context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A libinput context initialized with <a class="el" href="group__base.html#ga7512ea602d4b259085c47f6374b078d1" title="Create a new libinput context from udev. ">libinput_udev_create_context()</a> </td></tr>
    <tr><td class="paramname">seat_id</td><td>A seat identifier. This string must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga7512ea602d4b259085c47f6374b078d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7512ea602d4b259085c47f6374b078d1">&#9670;&nbsp;</a></span>libinput_udev_create_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput.html">libinput</a>* libinput_udev_create_context </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct udev *&#160;</td>
          <td class="paramname"><em>udev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new libinput context from udev. </p>
<p>This context is inactive until assigned a seat ID with <a class="el" href="group__base.html#ga71a60660b30cb476495e75766222d144" title="Assign a seat to this libinput context. ">libinput_udev_assign_seat()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The callback interface </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data passed to the various callback interfaces. </td></tr>
    <tr><td class="paramname">udev</td><td>An already initialized udev context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized, but inactive libinput context or NULL on error </dd></dl>

</div>
</div>
<a id="ga7ed0797d23e34b650e0aeb98b5350309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ed0797d23e34b650e0aeb98b5350309">&#9670;&nbsp;</a></span>libinput_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput.html">libinput</a>* libinput_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference the libinput context. </p>
<p>After this, the context may have been destroyed, if the last reference was dereferenced. If so, the context is invalid and may not be interacted with.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>When the refcount reaches zero, <a class="el" href="group__base.html#ga7ed0797d23e34b650e0aeb98b5350309" title="Dereference the libinput context. ">libinput_unref()</a> releases resources even if a caller still holds refcounted references to related resources (e.g. a <a class="el" href="structlibinput__device.html" title="A base handle for accessing libinput devices. ">libinput_device</a>). When <a class="el" href="group__base.html#ga7ed0797d23e34b650e0aeb98b5350309" title="Dereference the libinput context. ">libinput_unref()</a> returns NULL, the caller must consider any resources related to that context invalid. See <a href="https://bugs.freedesktop.org/show_bug.cgi?id=91872">https://bugs.freedesktop.org/show_bug.cgi?id=91872</a>. Example code: </dd></dl>
<div class="fragment"><div class="line">li = <a class="code" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07">libinput_path_create_context</a>(&amp;interface, NULL);</div><div class="line">device = <a class="code" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b">libinput_path_add_device</a>(li, <span class="stringliteral">&quot;/dev/input/event0&quot;</span>);</div><div class="line"><span class="comment">// get extra reference to device</span></div><div class="line"><a class="code" href="group__device.html#ga3335d55a50f0c2fb0c5f496a3105d467">libinput_device_ref</a>(device);</div><div class="line"></div><div class="line"><span class="comment">// refcount reaches 0, so *all* resources are cleaned up,</span></div><div class="line"><span class="comment">// including device</span></div><div class="line"><a class="code" href="group__base.html#ga7ed0797d23e34b650e0aeb98b5350309">libinput_unref</a>(li);</div><div class="line"></div><div class="line"><span class="comment">// INCORRECT: device has been cleaned up and must not be used</span></div><div class="line"><span class="comment">// li = libinput_device_get_context(device);</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if context was destroyed otherwise the passed context </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
