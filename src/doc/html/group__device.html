<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>libinput: Initialization and manipulation of input devices</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="bootstrap.css" rel="stylesheet" type="text/css"/>
        <link href="bootstrap.css" rel="stylesheet" type="text/css" />
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">libinput 1.6.3</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Initialization and manipulation of input devices</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibinput__device.html">libinput_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base handle for accessing libinput devices.  <a href="structlibinput__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibinput__device__group.html">libinput_device_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base handle for accessing libinput device groups.  <a href="structlibinput__device__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibinput__tablet__tool.html">libinput_tablet_tool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a tool being used by a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability.  <a href="structlibinput__tablet__tool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3110cdddce94a1df0b8a3306909c8f15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga3110cdddce94a1df0b8a3306909c8f15">libinput_device_capability</a> { <br />
&#160;&#160;<a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a733315d968cac7bd569b43b71664ae4b">LIBINPUT_DEVICE_CAP_KEYBOARD</a>, 
<a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a6e7c3249a8f0503fce7e0a5effc4d73f">LIBINPUT_DEVICE_CAP_POINTER</a>, 
<a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15aad61f92a8154c9017d4e621c768712aa">LIBINPUT_DEVICE_CAP_TOUCH</a>, 
<a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a>, 
<br />
&#160;&#160;<a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a>, 
<a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a592711b6976e0dab448a1ad8f412d527">LIBINPUT_DEVICE_CAP_GESTURE</a>
<br />
 }<tr class="memdesc:ga3110cdddce94a1df0b8a3306909c8f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capabilities on a device.  <a href="group__device.html#ga3110cdddce94a1df0b8a3306909c8f15">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga3110cdddce94a1df0b8a3306909c8f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360bdea89a75606472a0b5d72678bd17"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga360bdea89a75606472a0b5d72678bd17">libinput_key_state</a> { <a class="el" href="group__device.html#gga360bdea89a75606472a0b5d72678bd17a40f08dfe7bf96603f75bba186721992c">LIBINPUT_KEY_STATE_RELEASED</a>, 
<a class="el" href="group__device.html#gga360bdea89a75606472a0b5d72678bd17a3fa7cb12e694a4b1310f6df77e93d46e">LIBINPUT_KEY_STATE_PRESSED</a>
 }<tr class="memdesc:ga360bdea89a75606472a0b5d72678bd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical state of a key.  <a href="group__device.html#ga360bdea89a75606472a0b5d72678bd17">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga360bdea89a75606472a0b5d72678bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ec9afaec2e5407e3c5248faedd1970"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga37ec9afaec2e5407e3c5248faedd1970">libinput_led</a> { <a class="el" href="group__device.html#gga37ec9afaec2e5407e3c5248faedd1970aa82d6090fb4615d2379f59c06c79588a">LIBINPUT_LED_NUM_LOCK</a>, 
<a class="el" href="group__device.html#gga37ec9afaec2e5407e3c5248faedd1970a10cf3c49445b0baf5e91590391e59ebe">LIBINPUT_LED_CAPS_LOCK</a>, 
<a class="el" href="group__device.html#gga37ec9afaec2e5407e3c5248faedd1970a1914ddccb1739d77543767d7768e3abd">LIBINPUT_LED_SCROLL_LOCK</a>
 }<tr class="memdesc:ga37ec9afaec2e5407e3c5248faedd1970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask reflecting LEDs on a device.  <a href="group__device.html#ga37ec9afaec2e5407e3c5248faedd1970">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga37ec9afaec2e5407e3c5248faedd1970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga543a8bb3f2d7421f76e63bb4ee2fb5bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga543a8bb3f2d7421f76e63bb4ee2fb5bf">libinput_button_state</a> { <a class="el" href="group__device.html#gga543a8bb3f2d7421f76e63bb4ee2fb5bfad20bd759a424b497d7d363ef136f856b">LIBINPUT_BUTTON_STATE_RELEASED</a>, 
<a class="el" href="group__device.html#gga543a8bb3f2d7421f76e63bb4ee2fb5bfa68b58fac43509a92230c315993dcf6b4">LIBINPUT_BUTTON_STATE_PRESSED</a>
 }<tr class="memdesc:ga543a8bb3f2d7421f76e63bb4ee2fb5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical state of a physical button.  <a href="group__device.html#ga543a8bb3f2d7421f76e63bb4ee2fb5bf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga543a8bb3f2d7421f76e63bb4ee2fb5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cd15b9476a4a60f25470df8d67483c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga82cd15b9476a4a60f25470df8d67483c">libinput_pointer_axis</a> { <a class="el" href="group__device.html#gga82cd15b9476a4a60f25470df8d67483ca538dfb7d4ab598030af4d57aac55a1e5">LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL</a>, 
<a class="el" href="group__device.html#gga82cd15b9476a4a60f25470df8d67483caf0618a16f29ca56a8df0b624442f9852">LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL</a>
 }<tr class="memdesc:ga82cd15b9476a4a60f25470df8d67483c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axes on a device with the capability <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a6e7c3249a8f0503fce7e0a5effc4d73f">LIBINPUT_DEVICE_CAP_POINTER</a> that are not x or y coordinates.  <a href="group__device.html#ga82cd15b9476a4a60f25470df8d67483c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga82cd15b9476a4a60f25470df8d67483c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c012d8f6d7656fb795dc7bdf9d6551"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga76c012d8f6d7656fb795dc7bdf9d6551">libinput_pointer_axis_source</a> { <a class="el" href="group__device.html#gga76c012d8f6d7656fb795dc7bdf9d6551a60e7f4a41ceda06fe3eba2d512dc8ec9">LIBINPUT_POINTER_AXIS_SOURCE_WHEEL</a>, 
<a class="el" href="group__device.html#gga76c012d8f6d7656fb795dc7bdf9d6551a6a55790b11ef0aaecb897329d29a9fbb">LIBINPUT_POINTER_AXIS_SOURCE_FINGER</a>, 
<a class="el" href="group__device.html#gga76c012d8f6d7656fb795dc7bdf9d6551a3843fac25b1895de1d05191daf4527f6">LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS</a>
 }<tr class="memdesc:ga76c012d8f6d7656fb795dc7bdf9d6551"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source for a libinput_pointer_axis event.  <a href="group__device.html#ga76c012d8f6d7656fb795dc7bdf9d6551">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga76c012d8f6d7656fb795dc7bdf9d6551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8348e628baa2646d31abf0fe7245924f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga8348e628baa2646d31abf0fe7245924f">libinput_tablet_tool_type</a> { <br />
&#160;&#160;<a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fa9a76daea205049e4b71b0c30bb203436">LIBINPUT_TABLET_TOOL_TYPE_PEN</a>, 
<a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fa69812dd85e9d5b6775ecaf52ece3c19f">LIBINPUT_TABLET_TOOL_TYPE_ERASER</a>, 
<a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fad4a91e99e064f8172bd2ab8310c106d0">LIBINPUT_TABLET_TOOL_TYPE_BRUSH</a>, 
<a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924faec53813f855d7009fb1476c4a95990c6">LIBINPUT_TABLET_TOOL_TYPE_PENCIL</a>, 
<br />
&#160;&#160;<a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fa34519f7fadd32713f2383e6142016bb3">LIBINPUT_TABLET_TOOL_TYPE_AIRBRUSH</a>, 
<a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fa2544090800eca843af88bb2cf383e92e">LIBINPUT_TABLET_TOOL_TYPE_MOUSE</a>, 
<a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fa56a0427909230244aeedad4e48b0384c">LIBINPUT_TABLET_TOOL_TYPE_LENS</a>
<br />
 }<tr class="memdesc:ga8348e628baa2646d31abf0fe7245924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available tool types for a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability.  <a href="group__device.html#ga8348e628baa2646d31abf0fe7245924f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8348e628baa2646d31abf0fe7245924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f9b346c0338de742583a8e7c2b0628"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga54f9b346c0338de742583a8e7c2b0628">libinput_tablet_tool_proximity_state</a> { <a class="el" href="group__device.html#gga54f9b346c0338de742583a8e7c2b0628aca836e7d6fb61219ba4627ccaf0b47f8">LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT</a>, 
<a class="el" href="group__device.html#gga54f9b346c0338de742583a8e7c2b0628a90e9036c5474e8d5675549ceadcbd5f2">LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN</a>
 }<tr class="memdesc:ga54f9b346c0338de742583a8e7c2b0628"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of proximity for a tool on a device.  <a href="group__device.html#ga54f9b346c0338de742583a8e7c2b0628">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga54f9b346c0338de742583a8e7c2b0628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8383829ae67efea5543fb8af117091"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gabc8383829ae67efea5543fb8af117091">libinput_tablet_tool_tip_state</a> { <a class="el" href="group__device.html#ggabc8383829ae67efea5543fb8af117091aeeb7a764816c32a910bbdb14314ba613">LIBINPUT_TABLET_TOOL_TIP_UP</a>, 
<a class="el" href="group__device.html#ggabc8383829ae67efea5543fb8af117091a5d3293f81d157a683b614ba98605a419">LIBINPUT_TABLET_TOOL_TIP_DOWN</a>
 }<tr class="memdesc:gabc8383829ae67efea5543fb8af117091"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tip contact state for a tool on a device.  <a href="group__device.html#gabc8383829ae67efea5543fb8af117091">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gabc8383829ae67efea5543fb8af117091"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3335d55a50f0c2fb0c5f496a3105d467"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga3335d55a50f0c2fb0c5f496a3105d467">libinput_device_ref</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga3335d55a50f0c2fb0c5f496a3105d467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the refcount of the input device.  <a href="#ga3335d55a50f0c2fb0c5f496a3105d467">More...</a><br /></td></tr>
<tr class="separator:ga3335d55a50f0c2fb0c5f496a3105d467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857340e2dab06c7f7d84173a5a1fa427"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga857340e2dab06c7f7d84173a5a1fa427">libinput_device_unref</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga857340e2dab06c7f7d84173a5a1fa427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the refcount of the input device.  <a href="#ga857340e2dab06c7f7d84173a5a1fa427">More...</a><br /></td></tr>
<tr class="separator:ga857340e2dab06c7f7d84173a5a1fa427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6243ad6005b2ce2a5ecfd1b04787fe93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga6243ad6005b2ce2a5ecfd1b04787fe93">libinput_device_set_user_data</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device, void *user_data)</td></tr>
<tr class="memdesc:ga6243ad6005b2ce2a5ecfd1b04787fe93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set caller-specific data associated with this input device.  <a href="#ga6243ad6005b2ce2a5ecfd1b04787fe93">More...</a><br /></td></tr>
<tr class="separator:ga6243ad6005b2ce2a5ecfd1b04787fe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c902f56206a5d441e50c3a95ec458b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaf5c902f56206a5d441e50c3a95ec458b">libinput_device_get_user_data</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:gaf5c902f56206a5d441e50c3a95ec458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the caller-specific data associated with this input device, if any.  <a href="#gaf5c902f56206a5d441e50c3a95ec458b">More...</a><br /></td></tr>
<tr class="separator:gaf5c902f56206a5d441e50c3a95ec458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c6868911d8aba103278c9208d5205e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput.html">libinput</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga90c6868911d8aba103278c9208d5205e">libinput_device_get_context</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga90c6868911d8aba103278c9208d5205e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the libinput context from the device.  <a href="#ga90c6868911d8aba103278c9208d5205e">More...</a><br /></td></tr>
<tr class="separator:ga90c6868911d8aba103278c9208d5205e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0edc58e5a022b48a8d8416f63d2860df"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga0edc58e5a022b48a8d8416f63d2860df">libinput_device_get_device_group</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga0edc58e5a022b48a8d8416f63d2860df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device group this device is assigned to.  <a href="#ga0edc58e5a022b48a8d8416f63d2860df">More...</a><br /></td></tr>
<tr class="separator:ga0edc58e5a022b48a8d8416f63d2860df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106bbe58e6c3a6d1327c9bcbbf2a03f6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga106bbe58e6c3a6d1327c9bcbbf2a03f6">libinput_device_get_sysname</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga106bbe58e6c3a6d1327c9bcbbf2a03f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the system name of the device.  <a href="#ga106bbe58e6c3a6d1327c9bcbbf2a03f6">More...</a><br /></td></tr>
<tr class="separator:ga106bbe58e6c3a6d1327c9bcbbf2a03f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31655d2c2f173d059b3f891801c0a429"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga31655d2c2f173d059b3f891801c0a429">libinput_device_get_name</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga31655d2c2f173d059b3f891801c0a429"><td class="mdescLeft">&#160;</td><td class="mdescRight">The descriptive device name as advertised by the kernel and/or the hardware itself.  <a href="#ga31655d2c2f173d059b3f891801c0a429">More...</a><br /></td></tr>
<tr class="separator:ga31655d2c2f173d059b3f891801c0a429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae011910b4a673f1293a20a84be4e52e2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gae011910b4a673f1293a20a84be4e52e2">libinput_device_get_id_product</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:gae011910b4a673f1293a20a84be4e52e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the product ID for this device.  <a href="#gae011910b4a673f1293a20a84be4e52e2">More...</a><br /></td></tr>
<tr class="separator:gae011910b4a673f1293a20a84be4e52e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9e4c074b03da790de5e117c71ce8d50"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gad9e4c074b03da790de5e117c71ce8d50">libinput_device_get_id_vendor</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:gad9e4c074b03da790de5e117c71ce8d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vendor ID for this device.  <a href="#gad9e4c074b03da790de5e117c71ce8d50">More...</a><br /></td></tr>
<tr class="separator:gad9e4c074b03da790de5e117c71ce8d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48626f6190e9c9bc14abb704e66cc22"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaf48626f6190e9c9bc14abb704e66cc22">libinput_device_get_output_name</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:gaf48626f6190e9c9bc14abb704e66cc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">A device may be mapped to a single output, or all available outputs.  <a href="#gaf48626f6190e9c9bc14abb704e66cc22">More...</a><br /></td></tr>
<tr class="separator:gaf48626f6190e9c9bc14abb704e66cc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27823edb40750992a1a05e7a9f5dc8f0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__seat.html">libinput_seat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga27823edb40750992a1a05e7a9f5dc8f0">libinput_device_get_seat</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga27823edb40750992a1a05e7a9f5dc8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the seat associated with this input device, see <a class="el" href="seats.html">Seats</a> for details.  <a href="#ga27823edb40750992a1a05e7a9f5dc8f0">More...</a><br /></td></tr>
<tr class="separator:ga27823edb40750992a1a05e7a9f5dc8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f76acc43c8684a13f232073ee829b50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga9f76acc43c8684a13f232073ee829b50">libinput_device_set_seat_logical_name</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device, const char *name)</td></tr>
<tr class="memdesc:ga9f76acc43c8684a13f232073ee829b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the logical seat associated with this device by removing the device and adding it to the new seat.  <a href="#ga9f76acc43c8684a13f232073ee829b50">More...</a><br /></td></tr>
<tr class="separator:ga9f76acc43c8684a13f232073ee829b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc690c6679f547c46d9f41182a0e7c9"><td class="memItemLeft" align="right" valign="top">struct udev_device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaedc690c6679f547c46d9f41182a0e7c9">libinput_device_get_udev_device</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:gaedc690c6679f547c46d9f41182a0e7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a udev handle to the device that is this libinput device, if any.  <a href="#gaedc690c6679f547c46d9f41182a0e7c9">More...</a><br /></td></tr>
<tr class="separator:gaedc690c6679f547c46d9f41182a0e7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb3ddfb91e6bd38b6356a5bb51547ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gafdb3ddfb91e6bd38b6356a5bb51547ad">libinput_device_led_update</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device, enum <a class="el" href="group__device.html#ga37ec9afaec2e5407e3c5248faedd1970">libinput_led</a> leds)</td></tr>
<tr class="memdesc:gafdb3ddfb91e6bd38b6356a5bb51547ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the LEDs on the device, if any.  <a href="#gafdb3ddfb91e6bd38b6356a5bb51547ad">More...</a><br /></td></tr>
<tr class="separator:gafdb3ddfb91e6bd38b6356a5bb51547ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32d887454e8baf8aaeeb635329aef89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaa32d887454e8baf8aaeeb635329aef89">libinput_device_has_capability</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device, enum <a class="el" href="group__device.html#ga3110cdddce94a1df0b8a3306909c8f15">libinput_device_capability</a> capability)</td></tr>
<tr class="memdesc:gaa32d887454e8baf8aaeeb635329aef89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given device has the specified capability.  <a href="#gaa32d887454e8baf8aaeeb635329aef89">More...</a><br /></td></tr>
<tr class="separator:gaa32d887454e8baf8aaeeb635329aef89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91ae9014902fafe4f015e1f42233d27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gab91ae9014902fafe4f015e1f42233d27">libinput_device_get_size</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device, double *width, double *height)</td></tr>
<tr class="memdesc:gab91ae9014902fafe4f015e1f42233d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical size of a device in mm, where meaningful.  <a href="#gab91ae9014902fafe4f015e1f42233d27">More...</a><br /></td></tr>
<tr class="separator:gab91ae9014902fafe4f015e1f42233d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf63f10e5120daf174bd7943169f45bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaaf63f10e5120daf174bd7943169f45bf">libinput_device_pointer_has_button</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device, uint32_t code)</td></tr>
<tr class="memdesc:gaaf63f10e5120daf174bd7943169f45bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a6e7c3249a8f0503fce7e0a5effc4d73f">LIBINPUT_DEVICE_CAP_POINTER</a> device has a button with the given code (see linux/input.h).  <a href="#gaaf63f10e5120daf174bd7943169f45bf">More...</a><br /></td></tr>
<tr class="separator:gaaf63f10e5120daf174bd7943169f45bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80efc6bbab881c6785f0184ddc97c5ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga80efc6bbab881c6785f0184ddc97c5ce">libinput_device_keyboard_has_key</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device, uint32_t code)</td></tr>
<tr class="memdesc:ga80efc6bbab881c6785f0184ddc97c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a733315d968cac7bd569b43b71664ae4b">LIBINPUT_DEVICE_CAP_KEYBOARD</a> device has a key with the given code (see linux/input.h).  <a href="#ga80efc6bbab881c6785f0184ddc97c5ce">More...</a><br /></td></tr>
<tr class="separator:ga80efc6bbab881c6785f0184ddc97c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c5a5703982bcedc71a0470278258710"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga2c5a5703982bcedc71a0470278258710">libinput_device_tablet_pad_get_num_buttons</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga2c5a5703982bcedc71a0470278258710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of buttons on a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability.  <a href="#ga2c5a5703982bcedc71a0470278258710">More...</a><br /></td></tr>
<tr class="separator:ga2c5a5703982bcedc71a0470278258710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624cd4cb5fcd049fe88b2ab5f0a649cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga624cd4cb5fcd049fe88b2ab5f0a649cb">libinput_device_tablet_pad_get_num_rings</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:ga624cd4cb5fcd049fe88b2ab5f0a649cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rings a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability provides.  <a href="#ga624cd4cb5fcd049fe88b2ab5f0a649cb">More...</a><br /></td></tr>
<tr class="separator:ga624cd4cb5fcd049fe88b2ab5f0a649cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0696b32b500ccc0876396a184e22c01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaa0696b32b500ccc0876396a184e22c01">libinput_device_tablet_pad_get_num_strips</a> (struct <a class="el" href="structlibinput__device.html">libinput_device</a> *device)</td></tr>
<tr class="memdesc:gaa0696b32b500ccc0876396a184e22c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of strips a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability provides.  <a href="#gaa0696b32b500ccc0876396a184e22c01">More...</a><br /></td></tr>
<tr class="separator:gaa0696b32b500ccc0876396a184e22c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f2803f681e074e56e0da63e4ccead2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga72f2803f681e074e56e0da63e4ccead2">libinput_device_group_ref</a> (struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *group)</td></tr>
<tr class="memdesc:ga72f2803f681e074e56e0da63e4ccead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the refcount of the device group.  <a href="#ga72f2803f681e074e56e0da63e4ccead2">More...</a><br /></td></tr>
<tr class="separator:ga72f2803f681e074e56e0da63e4ccead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371124d3d3bec0a7f946acd1c4417efe"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga371124d3d3bec0a7f946acd1c4417efe">libinput_device_group_unref</a> (struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *group)</td></tr>
<tr class="memdesc:ga371124d3d3bec0a7f946acd1c4417efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the refcount of the device group.  <a href="#ga371124d3d3bec0a7f946acd1c4417efe">More...</a><br /></td></tr>
<tr class="separator:ga371124d3d3bec0a7f946acd1c4417efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf252f7535939d813ebe6eb7b2b792446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaf252f7535939d813ebe6eb7b2b792446">libinput_device_group_set_user_data</a> (struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *group, void *user_data)</td></tr>
<tr class="memdesc:gaf252f7535939d813ebe6eb7b2b792446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set caller-specific data associated with this device group.  <a href="#gaf252f7535939d813ebe6eb7b2b792446">More...</a><br /></td></tr>
<tr class="separator:gaf252f7535939d813ebe6eb7b2b792446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779d66e502b17a4c4aae6d3c773470f9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga779d66e502b17a4c4aae6d3c773470f9">libinput_device_group_get_user_data</a> (struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *group)</td></tr>
<tr class="memdesc:ga779d66e502b17a4c4aae6d3c773470f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the caller-specific data associated with this input device group, if any.  <a href="#ga779d66e502b17a4c4aae6d3c773470f9">More...</a><br /></td></tr>
<tr class="separator:ga779d66e502b17a4c4aae6d3c773470f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga543a8bb3f2d7421f76e63bb4ee2fb5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga543a8bb3f2d7421f76e63bb4ee2fb5bf">&#9670;&nbsp;</a></span>libinput_button_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga543a8bb3f2d7421f76e63bb4ee2fb5bf">libinput_button_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical state of a physical button. </p>
<p>Note that the logical state may not represent the physical state of the button. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga543a8bb3f2d7421f76e63bb4ee2fb5bfad20bd759a424b497d7d363ef136f856b"></a>LIBINPUT_BUTTON_STATE_RELEASED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga543a8bb3f2d7421f76e63bb4ee2fb5bfa68b58fac43509a92230c315993dcf6b4"></a>LIBINPUT_BUTTON_STATE_PRESSED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga3110cdddce94a1df0b8a3306909c8f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3110cdddce94a1df0b8a3306909c8f15">&#9670;&nbsp;</a></span>libinput_device_capability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga3110cdddce94a1df0b8a3306909c8f15">libinput_device_capability</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capabilities on a device. </p>
<p>A device may have one or more capabilities at a time, capabilities remain static for the lifetime of the device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3110cdddce94a1df0b8a3306909c8f15a733315d968cac7bd569b43b71664ae4b"></a>LIBINPUT_DEVICE_CAP_KEYBOARD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3110cdddce94a1df0b8a3306909c8f15a6e7c3249a8f0503fce7e0a5effc4d73f"></a>LIBINPUT_DEVICE_CAP_POINTER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3110cdddce94a1df0b8a3306909c8f15aad61f92a8154c9017d4e621c768712aa"></a>LIBINPUT_DEVICE_CAP_TOUCH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d"></a>LIBINPUT_DEVICE_CAP_TABLET_TOOL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f"></a>LIBINPUT_DEVICE_CAP_TABLET_PAD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3110cdddce94a1df0b8a3306909c8f15a592711b6976e0dab448a1ad8f412d527"></a>LIBINPUT_DEVICE_CAP_GESTURE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga360bdea89a75606472a0b5d72678bd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga360bdea89a75606472a0b5d72678bd17">&#9670;&nbsp;</a></span>libinput_key_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga360bdea89a75606472a0b5d72678bd17">libinput_key_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical state of a key. </p>
<p>Note that the logical state may not represent the physical state of the key. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga360bdea89a75606472a0b5d72678bd17a40f08dfe7bf96603f75bba186721992c"></a>LIBINPUT_KEY_STATE_RELEASED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga360bdea89a75606472a0b5d72678bd17a3fa7cb12e694a4b1310f6df77e93d46e"></a>LIBINPUT_KEY_STATE_PRESSED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga37ec9afaec2e5407e3c5248faedd1970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ec9afaec2e5407e3c5248faedd1970">&#9670;&nbsp;</a></span>libinput_led</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga37ec9afaec2e5407e3c5248faedd1970">libinput_led</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask reflecting LEDs on a device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga37ec9afaec2e5407e3c5248faedd1970aa82d6090fb4615d2379f59c06c79588a"></a>LIBINPUT_LED_NUM_LOCK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga37ec9afaec2e5407e3c5248faedd1970a10cf3c49445b0baf5e91590391e59ebe"></a>LIBINPUT_LED_CAPS_LOCK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga37ec9afaec2e5407e3c5248faedd1970a1914ddccb1739d77543767d7768e3abd"></a>LIBINPUT_LED_SCROLL_LOCK&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga82cd15b9476a4a60f25470df8d67483c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82cd15b9476a4a60f25470df8d67483c">&#9670;&nbsp;</a></span>libinput_pointer_axis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga82cd15b9476a4a60f25470df8d67483c">libinput_pointer_axis</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Axes on a device with the capability <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a6e7c3249a8f0503fce7e0a5effc4d73f">LIBINPUT_DEVICE_CAP_POINTER</a> that are not x or y coordinates. </p>
<p>The two scroll axes <a class="el" href="group__device.html#gga82cd15b9476a4a60f25470df8d67483ca538dfb7d4ab598030af4d57aac55a1e5">LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL</a> and <a class="el" href="group__device.html#gga82cd15b9476a4a60f25470df8d67483caf0618a16f29ca56a8df0b624442f9852">LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL</a> are engaged separately, depending on the device. libinput provides some scroll direction locking but it is up to the caller to determine which axis is needed and appropriate in the current interaction </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga82cd15b9476a4a60f25470df8d67483ca538dfb7d4ab598030af4d57aac55a1e5"></a>LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga82cd15b9476a4a60f25470df8d67483caf0618a16f29ca56a8df0b624442f9852"></a>LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga76c012d8f6d7656fb795dc7bdf9d6551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76c012d8f6d7656fb795dc7bdf9d6551">&#9670;&nbsp;</a></span>libinput_pointer_axis_source</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga76c012d8f6d7656fb795dc7bdf9d6551">libinput_pointer_axis_source</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The source for a libinput_pointer_axis event. </p>
<p>See <a class="el" href="group__event__pointer.html#ga2116f4bbedb61532e71d16c4f87bd4ca" title="Return the source for a given axis event. ">libinput_event_pointer_get_axis_source()</a> for details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga76c012d8f6d7656fb795dc7bdf9d6551a60e7f4a41ceda06fe3eba2d512dc8ec9"></a>LIBINPUT_POINTER_AXIS_SOURCE_WHEEL&#160;</td><td class="fielddoc"><p>The event is caused by the rotation of a wheel. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76c012d8f6d7656fb795dc7bdf9d6551a6a55790b11ef0aaecb897329d29a9fbb"></a>LIBINPUT_POINTER_AXIS_SOURCE_FINGER&#160;</td><td class="fielddoc"><p>The event is caused by the movement of one or more fingers on a device. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76c012d8f6d7656fb795dc7bdf9d6551a3843fac25b1895de1d05191daf4527f6"></a>LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS&#160;</td><td class="fielddoc"><p>The event is caused by the motion of some device. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga54f9b346c0338de742583a8e7c2b0628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f9b346c0338de742583a8e7c2b0628">&#9670;&nbsp;</a></span>libinput_tablet_tool_proximity_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga54f9b346c0338de742583a8e7c2b0628">libinput_tablet_tool_proximity_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The state of proximity for a tool on a device. </p>
<p>The device must have the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability.</p>
<p>The proximity of a tool is a binary state signalling whether the tool is within a detectable distance of the tablet device. A tool that is out of proximity cannot generate events.</p>
<p>On some hardware a tool goes out of proximity when it ceases to touch the surface. On other hardware, the tool is still detectable within a short distance (a few cm) off the surface. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga54f9b346c0338de742583a8e7c2b0628aca836e7d6fb61219ba4627ccaf0b47f8"></a>LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga54f9b346c0338de742583a8e7c2b0628a90e9036c5474e8d5675549ceadcbd5f2"></a>LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gabc8383829ae67efea5543fb8af117091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc8383829ae67efea5543fb8af117091">&#9670;&nbsp;</a></span>libinput_tablet_tool_tip_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#gabc8383829ae67efea5543fb8af117091">libinput_tablet_tool_tip_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The tip contact state for a tool on a device. </p>
<p>The device must have the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability.</p>
<p>The tip contact state of a tool is a binary state signalling whether the tool is touching the surface of the tablet device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabc8383829ae67efea5543fb8af117091aeeb7a764816c32a910bbdb14314ba613"></a>LIBINPUT_TABLET_TOOL_TIP_UP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc8383829ae67efea5543fb8af117091a5d3293f81d157a683b614ba98605a419"></a>LIBINPUT_TABLET_TOOL_TIP_DOWN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga8348e628baa2646d31abf0fe7245924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8348e628baa2646d31abf0fe7245924f">&#9670;&nbsp;</a></span>libinput_tablet_tool_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga8348e628baa2646d31abf0fe7245924f">libinput_tablet_tool_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available tool types for a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15ad3eafb7274a330c5839f00030850db6d">LIBINPUT_DEVICE_CAP_TABLET_TOOL</a> capability. </p>
<p>The tool type defines the default usage of the tool as advertised by the manufacturer. Multiple different physical tools may share the same tool type, e.g. a Wacom Classic Pen, Wacom Pro Pen and a Wacom Grip Pen are all of type <a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fa9a76daea205049e4b71b0c30bb203436">LIBINPUT_TABLET_TOOL_TYPE_PEN</a>. Use <a class="el" href="group__event__tablet.html#ga5ba26a193ce809fab9234b2253bcfff8" title="Return the tool ID for a tool object. ">libinput_tablet_tool_get_tool_id()</a> to get a specific model where applicable.</p>
<p>Note that on some device, the eraser tool is on the tail end of a pen device. On other devices, e.g. MS Surface 3, the eraser is the pen tip while a button is held down.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__device.html#ga8348e628baa2646d31abf0fe7245924f">libinput_tablet_tool_type</a> can only describe the default physical type of the device. For devices with adjustable physical properties the tool type remains the same, i.e. putting a Wacom stroke nib into a classic pen leaves the tool type as <a class="el" href="group__device.html#gga8348e628baa2646d31abf0fe7245924fa9a76daea205049e4b71b0c30bb203436">LIBINPUT_TABLET_TOOL_TYPE_PEN</a>. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8348e628baa2646d31abf0fe7245924fa9a76daea205049e4b71b0c30bb203436"></a>LIBINPUT_TABLET_TOOL_TYPE_PEN&#160;</td><td class="fielddoc"><p>A generic pen. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8348e628baa2646d31abf0fe7245924fa69812dd85e9d5b6775ecaf52ece3c19f"></a>LIBINPUT_TABLET_TOOL_TYPE_ERASER&#160;</td><td class="fielddoc"><p>Eraser. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8348e628baa2646d31abf0fe7245924fad4a91e99e064f8172bd2ab8310c106d0"></a>LIBINPUT_TABLET_TOOL_TYPE_BRUSH&#160;</td><td class="fielddoc"><p>A paintbrush-like tool. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8348e628baa2646d31abf0fe7245924faec53813f855d7009fb1476c4a95990c6"></a>LIBINPUT_TABLET_TOOL_TYPE_PENCIL&#160;</td><td class="fielddoc"><p>Physical drawing tool, e.g. </p>
<p>Wacom Inking Pen </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8348e628baa2646d31abf0fe7245924fa34519f7fadd32713f2383e6142016bb3"></a>LIBINPUT_TABLET_TOOL_TYPE_AIRBRUSH&#160;</td><td class="fielddoc"><p>An airbrush-like tool. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8348e628baa2646d31abf0fe7245924fa2544090800eca843af88bb2cf383e92e"></a>LIBINPUT_TABLET_TOOL_TYPE_MOUSE&#160;</td><td class="fielddoc"><p>A mouse bound to the tablet. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8348e628baa2646d31abf0fe7245924fa56a0427909230244aeedad4e48b0384c"></a>LIBINPUT_TABLET_TOOL_TYPE_LENS&#160;</td><td class="fielddoc"><p>A mouse tool with a lens. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga90c6868911d8aba103278c9208d5205e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90c6868911d8aba103278c9208d5205e">&#9670;&nbsp;</a></span>libinput_device_get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput.html">libinput</a>* libinput_device_get_context </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the libinput context from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The libinput context for this device. </dd></dl>

</div>
</div>
<a id="ga0edc58e5a022b48a8d8416f63d2860df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0edc58e5a022b48a8d8416f63d2860df">&#9670;&nbsp;</a></span>libinput_device_get_device_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a>* libinput_device_get_device_group </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device group this device is assigned to. </p>
<p>Some physical devices like graphics tablets are represented by multiple kernel devices and thus by multiple struct <a class="el" href="structlibinput__device.html">libinput_device</a>.</p>
<p>libinput assigns these devices to the same <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> allowing the caller to identify such devices and adjust configuration settings accordingly. For example, setting a tablet to left-handed often means turning it upside down. A touch device on the same tablet would need to be turned upside down too to work correctly.</p>
<p>All devices are part of a device group though for most devices the group will be a singleton. A device is assigned to a device group on <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4da18343b29cc16ae2df09b9a3bff33b">LIBINPUT_EVENT_DEVICE_ADDED</a> and removed from that group on <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09">LIBINPUT_EVENT_DEVICE_REMOVED</a>. It is up to the caller to track how many devices are in each device group.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_2.png" alt="dot_inline_dotgraph_2.png" border="0" usemap="#dot_inline_dotgraph_2.map"/>
<map name="dot_inline_dotgraph_2.map" id="dot_inline_dotgraph_2.map"><area shape="rect" id="node1" href="structlibinput__device.html" title="mouse" alt="" coords="9,5,81,53"/>
<area shape="rect" id="node6" href="structlibinput__device__group.html" title="group 1" alt="" coords="5,101,84,149"/>
<area shape="rect" id="node2" href="structlibinput__device.html" title="keyboard" alt="" coords="105,5,195,53"/>
<area shape="rect" id="node7" href="structlibinput__device__group.html" title="group 2" alt="" coords="111,101,189,149"/>
<area shape="rect" id="node3" href="structlibinput__device.html" title="tablet pen" alt="" coords="219,5,313,53"/>
<area shape="rect" id="node8" href="structlibinput__device__group.html" title="group 3" alt="" coords="351,101,429,149"/>
<area shape="rect" id="node4" href="structlibinput__device.html" title="tablet touch" alt="" coords="337,5,443,53"/>
<area shape="rect" id="node5" href="structlibinput__device.html" title="tablet pad" alt="" coords="467,5,561,53"/>
</map>
</div>
<p>Device groups do not get re-used once the last device in the group was removed, i.e. unplugging and re-plugging a physical device with grouped devices will return a different device group after every unplug.</p>
<p>The returned device group is not refcounted and may become invalid after the next call to libinput. Use <a class="el" href="group__device.html#ga72f2803f681e074e56e0da63e4ccead2" title="Increase the refcount of the device group. ">libinput_device_group_ref()</a> and <a class="el" href="group__device.html#ga371124d3d3bec0a7f946acd1c4417efe" title="Decrease the refcount of the device group. ">libinput_device_group_unref()</a> to continue using the handle outside of the immediate scope.</p>
<p>Device groups are assigned based on the <b>LIBINPUT_DEVICE_GROUP</b> udev property, see <a class="el" href="udev_config.html">Static device configuration via udev</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The device group this device belongs to </dd></dl>

</div>
</div>
<a id="gae011910b4a673f1293a20a84be4e52e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae011910b4a673f1293a20a84be4e52e2">&#9670;&nbsp;</a></span>libinput_device_get_id_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libinput_device_get_id_product </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the product ID for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product ID of this device </dd></dl>

</div>
</div>
<a id="gad9e4c074b03da790de5e117c71ce8d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e4c074b03da790de5e117c71ce8d50">&#9670;&nbsp;</a></span>libinput_device_get_id_vendor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libinput_device_get_id_vendor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vendor ID for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vendor ID of this device </dd></dl>

</div>
</div>
<a id="ga31655d2c2f173d059b3f891801c0a429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31655d2c2f173d059b3f891801c0a429">&#9670;&nbsp;</a></span>libinput_device_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libinput_device_get_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The descriptive device name as advertised by the kernel and/or the hardware itself. </p>
<p>To get the sysname for this device, use <a class="el" href="group__device.html#ga106bbe58e6c3a6d1327c9bcbbf2a03f6" title="Get the system name of the device. ">libinput_device_get_sysname()</a>.</p>
<p>The lifetime of the returned string is tied to the struct <a class="el" href="structlibinput__device.html" title="A base handle for accessing libinput devices. ">libinput_device</a>. The string may be the empty string but is never NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The device name </dd></dl>

</div>
</div>
<a id="gaf48626f6190e9c9bc14abb704e66cc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf48626f6190e9c9bc14abb704e66cc22">&#9670;&nbsp;</a></span>libinput_device_get_output_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libinput_device_get_output_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A device may be mapped to a single output, or all available outputs. </p>
<p>If a device is mapped to a single output only, a relative device may not move beyond the boundaries of this output. An absolute device has its input coordinates mapped to the extents of this output.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of the output this device is mapped to, or NULL if no output is set </dd></dl>

</div>
</div>
<a id="ga27823edb40750992a1a05e7a9f5dc8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27823edb40750992a1a05e7a9f5dc8f0">&#9670;&nbsp;</a></span>libinput_device_get_seat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__seat.html">libinput_seat</a>* libinput_device_get_seat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the seat associated with this input device, see <a class="el" href="seats.html">Seats</a> for details. </p>
<p>A seat can be uniquely identified by the physical and logical seat name. There will ever be only one seat instance with a given physical and logical seat name pair at any given time, but if no external reference is kept, it may be destroyed if no device belonging to it is left.</p>
<p>The returned seat is not refcounted and may become invalid after the next call to libinput. Use <a class="el" href="group__seat.html#ga60445ab81e8ee3a10b85e88617231069" title="Increase the refcount of the seat. ">libinput_seat_ref()</a> and <a class="el" href="group__seat.html#ga81d52d0e9332f07c39a899c8c2fd3400" title="Decrease the refcount of the seat. ">libinput_seat_unref()</a> to continue using the handle outside of the immediate scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The seat this input device belongs to </dd></dl>

</div>
</div>
<a id="gab91ae9014902fafe4f015e1f42233d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab91ae9014902fafe4f015e1f42233d27">&#9670;&nbsp;</a></span>libinput_device_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_get_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the physical size of a device in mm, where meaningful. </p>
<p>This function only succeeds on devices with the required data, i.e. tablets, touchpads and touchscreens.</p>
<p>If this function returns nonzero, width and height are unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device </td></tr>
    <tr><td class="paramname">width</td><td>Set to the width of the device </td></tr>
    <tr><td class="paramname">height</td><td>Set to the height of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or nonzero otherwise </dd></dl>

</div>
</div>
<a id="ga106bbe58e6c3a6d1327c9bcbbf2a03f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga106bbe58e6c3a6d1327c9bcbbf2a03f6">&#9670;&nbsp;</a></span>libinput_device_get_sysname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libinput_device_get_sysname </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the system name of the device. </p>
<p>To get the descriptive device name, use <a class="el" href="group__device.html#ga31655d2c2f173d059b3f891801c0a429" title="The descriptive device name as advertised by the kernel and/or the hardware itself. ">libinput_device_get_name()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>System name of the device </dd></dl>

</div>
</div>
<a id="gaedc690c6679f547c46d9f41182a0e7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc690c6679f547c46d9f41182a0e7c9">&#9670;&nbsp;</a></span>libinput_device_get_udev_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct udev_device* libinput_device_get_udev_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a udev handle to the device that is this libinput device, if any. </p>
<p>The returned handle has a refcount of at least 1, the caller must call <em>udev_device_unref()</em> once to release the associated resources. See the <a href="http://www.freedesktop.org/software/systemd/libudev/">libudev documentation</a> for details.</p>
<p>Some devices may not have a udev device, or the udev device may be unobtainable. This function returns NULL if no udev device was available.</p>
<p>Calling this function multiple times for the same device may not return the same udev handle each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A udev handle to the device with a refcount of &gt;= 1 or NULL. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>This device is not represented by a udev device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5c902f56206a5d441e50c3a95ec458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c902f56206a5d441e50c3a95ec458b">&#9670;&nbsp;</a></span>libinput_device_get_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* libinput_device_get_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the caller-specific data associated with this input device, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Caller-specific data pointer or NULL if none was set </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__device.html#ga6243ad6005b2ce2a5ecfd1b04787fe93" title="Set caller-specific data associated with this input device. ">libinput_device_set_user_data</a> </dd></dl>

</div>
</div>
<a id="ga779d66e502b17a4c4aae6d3c773470f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga779d66e502b17a4c4aae6d3c773470f9">&#9670;&nbsp;</a></span>libinput_device_group_get_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* libinput_device_group_get_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the caller-specific data associated with this input device group, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>A previously obtained group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Caller-specific data pointer or NULL if none was set </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__device.html#gaf252f7535939d813ebe6eb7b2b792446" title="Set caller-specific data associated with this device group. ">libinput_device_group_set_user_data</a> </dd></dl>

</div>
</div>
<a id="ga72f2803f681e074e56e0da63e4ccead2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72f2803f681e074e56e0da63e4ccead2">&#9670;&nbsp;</a></span>libinput_device_group_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a>* libinput_device_group_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the device group. </p>
<p>A device group will be freed whenever the refcount reaches 0. This may happen during <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> if all devices of this group were removed from the system. A caller must ensure to reference the device group correctly to avoid dangling pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>A previously obtained device group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed device group </dd></dl>

</div>
</div>
<a id="gaf252f7535939d813ebe6eb7b2b792446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf252f7535939d813ebe6eb7b2b792446">&#9670;&nbsp;</a></span>libinput_device_group_set_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_device_group_set_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set caller-specific data associated with this device group. </p>
<p>libinput does not manage, look at, or modify this data. The caller must ensure the data is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>A previously obtained device group </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__device.html#ga779d66e502b17a4c4aae6d3c773470f9" title="Get the caller-specific data associated with this input device group, if any. ">libinput_device_group_get_user_data</a> </dd></dl>

</div>
</div>
<a id="ga371124d3d3bec0a7f946acd1c4417efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga371124d3d3bec0a7f946acd1c4417efe">&#9670;&nbsp;</a></span>libinput_device_group_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a>* libinput_device_group_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device__group.html">libinput_device_group</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the device group. </p>
<p>A device group will be freed whenever the refcount reaches 0. This may happen during <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> if all devices of this group were removed from the system. A caller must ensure to reference the device group correctly to avoid dangling pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>A previously obtained device group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the device group was destroyed, otherwise the passed device group </dd></dl>

</div>
</div>
<a id="gaa32d887454e8baf8aaeeb635329aef89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa32d887454e8baf8aaeeb635329aef89">&#9670;&nbsp;</a></span>libinput_device_has_capability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_has_capability </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__device.html#ga3110cdddce94a1df0b8a3306909c8f15">libinput_device_capability</a>&#160;</td>
          <td class="paramname"><em>capability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given device has the specified capability. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the given device has the capability or zero otherwise </dd></dl>

</div>
</div>
<a id="ga80efc6bbab881c6785f0184ddc97c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80efc6bbab881c6785f0184ddc97c5ce">&#9670;&nbsp;</a></span>libinput_device_keyboard_has_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_keyboard_has_key </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a733315d968cac7bd569b43b71664ae4b">LIBINPUT_DEVICE_CAP_KEYBOARD</a> device has a key with the given code (see linux/input.h). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A current input device </td></tr>
    <tr><td class="paramname">code</td><td>Key code to check for, e.g. <em>KEY_ESC</em></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the device supports this key code, 0 if it does not, -1 on error. </dd></dl>

</div>
</div>
<a id="gafdb3ddfb91e6bd38b6356a5bb51547ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb3ddfb91e6bd38b6356a5bb51547ad">&#9670;&nbsp;</a></span>libinput_device_led_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_device_led_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__device.html#ga37ec9afaec2e5407e3c5248faedd1970">libinput_led</a>&#160;</td>
          <td class="paramname"><em>leds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the LEDs on the device, if any. </p>
<p>If the device does not have LEDs, or does not have one or more of the LEDs given in the mask, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
    <tr><td class="paramname">leds</td><td>A mask of the LEDs to set, or unset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf63f10e5120daf174bd7943169f45bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf63f10e5120daf174bd7943169f45bf">&#9670;&nbsp;</a></span>libinput_device_pointer_has_button()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_pointer_has_button </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a6e7c3249a8f0503fce7e0a5effc4d73f">LIBINPUT_DEVICE_CAP_POINTER</a> device has a button with the given code (see linux/input.h). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A current input device </td></tr>
    <tr><td class="paramname">code</td><td>Button code to check for, e.g. <em>BTN_LEFT</em></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the device supports this button code, 0 if it does not, -1 on error. </dd></dl>

</div>
</div>
<a id="ga3335d55a50f0c2fb0c5f496a3105d467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3335d55a50f0c2fb0c5f496a3105d467">&#9670;&nbsp;</a></span>libinput_device_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__device.html">libinput_device</a>* libinput_device_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the refcount of the input device. </p>
<p>An input device will be freed whenever the refcount reaches 0. This may happen during <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> if the device was removed from the system. A caller must ensure to reference the device correctly to avoid dangling pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed device </dd></dl>

</div>
</div>
<a id="ga9f76acc43c8684a13f232073ee829b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f76acc43c8684a13f232073ee829b50">&#9670;&nbsp;</a></span>libinput_device_set_seat_logical_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_set_seat_logical_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the logical seat associated with this device by removing the device and adding it to the new seat. </p>
<p>This command is identical to physically unplugging the device, then re-plugging it as a member of the new seat. libinput will generate a <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09">LIBINPUT_EVENT_DEVICE_REMOVED</a> event and this <a class="el" href="structlibinput__device.html">libinput_device</a> is considered removed from the context; it will not generate further events and will be freed when the refcount reaches zero. A <a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4da18343b29cc16ae2df09b9a3bff33b">LIBINPUT_EVENT_DEVICE_ADDED</a> event is generated with a new <a class="el" href="structlibinput__device.html">libinput_device</a> handle. It is the caller's responsibility to update references to the new device accordingly.</p>
<p>If the logical seat name already exists in the device's physical seat, the device is added to this seat. Otherwise, a new seat is created.</p>
<dl class="section note"><dt>Note</dt><dd>This change applies to this device until removal or <a class="el" href="group__base.html#ga60662dc666f6188dc207467c9d8e99ab">libinput_suspend()</a>, whichever happens earlier.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
    <tr><td class="paramname">name</td><td>The new logical seat name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on error </dd></dl>

</div>
</div>
<a id="ga6243ad6005b2ce2a5ecfd1b04787fe93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6243ad6005b2ce2a5ecfd1b04787fe93">&#9670;&nbsp;</a></span>libinput_device_set_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_device_set_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set caller-specific data associated with this input device. </p>
<p>libinput does not manage, look at, or modify this data. The caller must ensure the data is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__device.html#gaf5c902f56206a5d441e50c3a95ec458b" title="Get the caller-specific data associated with this input device, if any. ">libinput_device_get_user_data</a> </dd></dl>

</div>
</div>
<a id="ga2c5a5703982bcedc71a0470278258710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c5a5703982bcedc71a0470278258710">&#9670;&nbsp;</a></span>libinput_device_tablet_pad_get_num_buttons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_tablet_pad_get_num_buttons </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of buttons on a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability. </p>
<p>Buttons on a pad device are numbered sequentially, see <a class="el" href="tablet-support.html#tablet-pad-buttons">Tablet pad button numbers</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A current input device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of buttons supported by the device. </dd></dl>

</div>
</div>
<a id="ga624cd4cb5fcd049fe88b2ab5f0a649cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga624cd4cb5fcd049fe88b2ab5f0a649cb">&#9670;&nbsp;</a></span>libinput_device_tablet_pad_get_num_rings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_tablet_pad_get_num_rings </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of rings a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability provides. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A current input device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rings or 0 if the device has no rings.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__tablet__pad.html#gae866be98b773edcf95ad9a36b5bbacb1" title="Returns the number of the ring that has changed state, with 0 being the first ring. ">libinput_event_tablet_pad_get_ring_number</a> </dd></dl>

</div>
</div>
<a id="gaa0696b32b500ccc0876396a184e22c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0696b32b500ccc0876396a184e22c01">&#9670;&nbsp;</a></span>libinput_device_tablet_pad_get_num_strips()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_device_tablet_pad_get_num_strips </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of strips a device with the <a class="el" href="group__device.html#gga3110cdddce94a1df0b8a3306909c8f15a98ec191d1a685df5cdf87a19b2ee9a9f">LIBINPUT_DEVICE_CAP_TABLET_PAD</a> capability provides. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A current input device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of strips or 0 if the device has no strips.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__tablet__pad.html#ga32792a10d7f86900a4f94e63037f68b6" title="Returns the number of the strip that has changed state, with 0 being the first strip. ">libinput_event_tablet_pad_get_strip_number</a> </dd></dl>

</div>
</div>
<a id="ga857340e2dab06c7f7d84173a5a1fa427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga857340e2dab06c7f7d84173a5a1fa427">&#9670;&nbsp;</a></span>libinput_device_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibinput__device.html">libinput_device</a>* libinput_device_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibinput__device.html">libinput_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the refcount of the input device. </p>
<p>An input device will be freed whenever the refcount reaches 0. This may happen during libinput_dispatch if the device was removed from the system. A caller must ensure to reference the device correctly to avoid dangling pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A previously obtained device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the device was destroyed, otherwise the passed device </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
